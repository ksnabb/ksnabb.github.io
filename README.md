* There are a lot of interresting things you can see when you do a little bit infra metrics on your app
* church numerals, in come language (clojure)
* thread, event loop, process
* type hierarchy (example geometric figures if it fits) in haskell

"""
is statement, which also appears in the first edition of this book, is just as true
now as it was when we wrote it twelve years ago. Developing a useful, general framework for expressing the relations among different types of entities (what philosophers
call “ontology”) seems intractably difficult. e main difference between the confusion that existed ten years ago and the confusion that exists now is that now a variety of inadequate ontological theories have been embodied in a plethora of correspondingly inadequate programming languages. For example, much of the complexity
of object-oriented programming languages—and the subtle and confusing differences
among contemporary object-oriented languages—centers on the treatment of generic
operations on interrelated types. Our own discussion of computational objects in Chapter 3 avoids these issues entirely. Readers familiar with object-oriented programming
will notice that we have much to say in chapter 3 about local state, but we do not even
mention “classes” or “inheritance.” In fact, we suspect that these problems cannot be adequately addressed in terms of computer-language design alone, without also drawing
on work in knowledge representation and automated reasoning.
"""